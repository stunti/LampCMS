<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is lisensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 * 	  the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website's Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attibutes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2011 (or current year) ExamNotes.net inc.
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: @package_version@
 *
 *
 */


namespace Lampcms\Template;


/**
 * Class for parsing vsprintf based templates
 *
 * @todo Template could have static function loopFilter()
 * and will be applied inside the loop()
 * this way it can possibly splice the array or
 * even modify the Iterator (cursor) before starting the loop
 * Could be helpful to limit the number of items to be looped
 *
 * @todo recursively check if value is_array() and if yes
 * the parse it first with loop() and then replace the value
 * of that key with the parsed version.
 *
 * This could be used for nested replies, should even
 * work with unlimited nesting levels
 *
 * @author Dmitri Snytkine
 *
 */
class Template
{

	/**
	 * Parse template, using input $aVars array of replacement
	 * variables to be used in the vsprintf() function
	 *
	 * @param array $aVars
	 *
	 * @param bool $merge if true will apply default values
	 * as well as making sure the elements or input
	 * array are in the correct order. This is very important
	 * if you not sure that array of values you passing has
	 * named elements in correct order.
	 * If you are 100% sure that elements are in correct order
	 * then set this to false to save function call
	 *
	 * @param Closure $func callback function to be applied
	 * to input array. The callback anonymous function MUST
	 * accept input array by reference and perform some
	 * operations on the actual array.
	 */
	public static function parse(array $aVars, $merge = true, \Closure $func = null){


		/**
		 * ORDER IS IMPORTANT:
		 * Closure functions applied first, then static function "func"
		 *
		 * Apply callback to array if
		 * callback was passed here
		 * callback MUST accept array by reference
		 * so that it can modify actual values in aVars
		 *
		 * The callback should be applied first,
		 * so that in case the template also has a function,
		 * it would be possible to use callback to add
		 * elements to the result array.
		 *
		 * This is useful when we have a cursor - a result
		 * of database select but also need to inject
		 * extra element(s) to the array of item which
		 * are not present in the database
		 */
		if(null !== $func){
			d('have Closure func');
			$func($aVars);

			//d('new aVars: '.print_r($aVars, 1));
		}

		/**
		 * A template may contain hard coded static property $func
		 *
		 * If it does then input array will be run through
		 * that $func function
		 * it MUST accept array by reference
		 * and modify actual array value
		 *
		 */
		if( (empty(static::$skip)) && is_callable(array('static', 'func')) ){
			static::func($aVars);
			//d('new aVars: '.print_r($aVars, 1));
		} else {
			//echo ' <b>Callback cancelled</b> ';
		}

		if($merge){
			$aVars = array_merge(static::$vars, $aVars);
		}

		return vsprintf(static::$tpl, $aVars);
	}

	/**
	 * @todo template may contain $loop static
	 * function, if it does then use it on
	 * passed array
	 *
	 * @param mixed $a could be array or object of type Iterator
	 * @param bool $merge
	 * @param Closure $func if passed, this callback function
	 * will be passed to each element's parse() function
	 *
	 * @throws InvalidArgumentException
	 */
	public static function loop($a, $merge = true, \Closure $func = null){
		
		/**
		 * Throw exception if Iterator is not
		 * an array and not instance of iterator
		 */
		if(!is_array($a) && (!is_object($a) || !($a instanceof \Iterator)) ){
			$err = '$a must be array of object instance of Iterator was: '.gettype($a);
			
			throw new \InvalidArgumentException($err);
		}



		/**
		 * Cannot just declare this $s as static inside the
		 * method
		 * because then it remembers this value
		 * even between parsing multiple times
		 * Instead we must recursively pass $s to itself
		 */
		$s = '';
		foreach($a as $aVars){
			if(is_string($aVars)){
				$vars = array($aVars);
				d('aVars now: '.print_r($vars, 1));
			}else {
				$vars = $aVars;
			}
			$s .= static::parse($vars, $merge, $func);
		}

		return $s;
	}


	/**
	 * Static getter for vars array
	 *
	 * @asKeys bool if true then return array of
	 * placeholder names. This type of array is useful for
	 * passing it to mongocollection->find() 2nd param
	 * to hint which field we need to select.
	 *
	 * @return array of $vars from template OR if
	 * asKeys is true then returns array of placeholder names
	 */
	public static function getVars($asKeys = false){
		if(isset(static::$vars)){
			$ret = static::$vars;
			if($asKeys){
				return array_keys($ret);
			}

			return $ret;
		}

		return array();
	}


	/**
	 * Static getter for $tpl
	 *
	 * @return string $tpl template
	 */
	public static function getTemplate(){
		return static::$tpl;
	}

}
