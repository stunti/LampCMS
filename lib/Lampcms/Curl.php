<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is lisensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 * 	  the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website's Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attibutes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2011 (or current year) ExamNotes.net inc.
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: @package_version@
 *
 *
 */

 
namespace Lampcms;


/**
 * Wrapper for curl functions
 * @author admin
 *
 */
class Curl extends LampcmsObject
{
	/**
	 * Headers returned from the http server
	 *
	 * @var array where keys are header name, values are values
	 */
	protected $aHeaders = array();

	/**
	 * Body of response (usually some html or xml)
	 * as returned from the http server
	 * @var srting
	 */
	protected $body;

	/**
	 * Array or response http headers
	 * @var array
	 */
	protected $aResponseHeaders = array();

	/**
	 * Array returned by curl_getinfo()
	 * @var array
	 */
	protected $info;

	/**
	 * Response code as returned by the http server
	 *
	 * @var string (numeric string)
	 */
	protected $httpResponseCode;

	/**
	 * Curl handle object
	 * @var object curl handle
	 */
	protected $request;



	/**
	 * Default values for
	 * timeout: 8 seconds
	 * useragent: Mozilla
	 *
	 * These can be overritten in getDocument in third param
	 * // used to also include this 'redirect' => 2,
	 * but now cannot include redirect limit because
	 * we handle redirects separately
	 *
	 * @var array
	 */
	protected $aOptions = array('timeout' => 8,
		'useragent' => 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.4) Gecko/20091016 Firefox/3.5.4 GTB5');


	/**
	 * Main method to get (retreive) the document from url
	 * as well as set the $this object with values
	 * This method makes use of special cache-control
	 * request headers: If-Modified-Since
	 * and If-None-Match
	 *
	 * @param string $url URI from which we requesting the document
	 *
	 * @param string $since value to use for the If-Modified-Since
	 * this should be in the rfs 2822 or 822 date/time format
	 * Ideally (really strongly recommended) this value should be
	 * previously received from the same http server from which
	 * we are currently requesting the document. It is usually
	 * important that the time is in the timezone of the server
	 * from which we requesting the document
	 *
	 * @param string $etag value to be used for the
	 * If-None-Match header. This should be the value previously
	 * received from the same http server for the same document
	 * that we currently requesting
	 *
	 * @param array $aOptions
	 *
	 * @return object $this
	 *
	 * @throws Exceptions are based on returned response code:
	 * 304, 404 and timeout result in special corresponding exceptions
	 *
	 *
	 */
	public function getDocument($url, $since = null, $etag = null, array $aOptions = array()){

		$aHeaders = array();
		$this->request = curl_init();

		if(false === curl_setopt($this->request, CURLOPT_URL, $url)){
			throw new \Exception('Unable to set url: '.$url);
		}

		//curl_setopt($this->request, CURLOPT_ENCODING, 'gzip');

		$this->setOptions($aOptions);

		if(null !== $since){
			$aHeaders['If-Modified-Since'] = $since;
		}

		if(!empty($etag)){
			$aHeaders['If-None-Match'] = $etag;
		}

		if(!empty($aHeaders)){
			$this->setHeaders($aHeaders);
		}

		$response = curl_exec($this->request);
		$this->info = curl_getinfo($this->request);
		$error = curl_error($this->request);
		$error_code = curl_errno($this->request);
		$header_size = curl_getinfo($this->request, CURLINFO_HEADER_SIZE);
		if(28 === (int)$error_code){
			throw new HttpTimeoutException($error);
		}

		$this->httpResponseCode = $intCode = curl_getinfo($this->request, CURLINFO_HTTP_CODE);
		$this->body = substr($response, $header_size);
		$header = substr($response, 0, $header_size);
		$headers = explode("\r\n", str_replace("\r\n\r\n", '', $header));

		foreach ($headers as $h) {
			if(preg_match('#(.*?)\:\s(.*)#', $h, $matches)){
				$this->aResponseHeaders[strtolower($matches[1])] = trim($matches[2]);
			}
		}

		switch($this->httpResponseCode){

			case 200:

				if(!empty($this->body)){

					$this->__destruct();

					return $this;
				}

				$ex = new HttpEmptyBodyException('Empty body');
				break;

			case 301:
			case 302:
			case 303:
			case 307:
				if('' !== $newLocation = $this->getHeader('Location')){
					// echo __LINE__.' redirect contains location: '.$newLocation. ' $intCode: '.$intCode."\n";

					$ex = new HttpRedirectException($newLocation, $intCode);
				} else {
					$ex = new HttpResponseErrorException('Error '.$intCode.' message: '.$this->getResponseStatus());
				}
				break;

			case 304:
				$ex = new Http304Exception('Content has not changed');
				break;

			case 401:
				$ex = new Http401Exception('Unauthorized login: '.$url);
				break;

			case 404:
				$ex = new Http404Exception('page not found at this url: '.$url);
				break;

			default:

				if($intCode >= 400 && $intCode < 500){
					$ex = new Http400Exception('Error '.$intCode, $intCode);
				} elseif ($intCode >= 500 && $intCode < 600){
					$ex = new Http500Exception('Error '.$intCode, $intCode);
				} else {
					$ex = new HttpResponseErrorException('Error '.$intCode.' message: '.$this->httpResponseCode);
				}

		}

		$this->__destruct();

		throw $ex;
	}

	
	/**
	 * Set request headers
	 * @param array $aHeaders
	 */
	public function setHeaders(array $aHeaders){
		foreach ($aHeaders as $key => $value) {
			$headers[] = $key.': '.$value;
		}

		curl_setopt($this->request, CURLOPT_HTTPHEADER, $headers);

		return $this;
	}

	
	/**
	 * Set curl options
	 * This MUST be run before sending out a request,
	 * usually it's run automatically from getDocument()
	 * @param array $aOptions
	 */
	protected function setOptions(array $aOptions = array()){
		d('starting to set curl options');
		
		if(!empty($aOptions)){
			$this->aOptions = array_merge($this->aOptions, $aOptions);
		}

		curl_setopt($this->request, CURLOPT_HEADER, true);
		curl_setopt($this->request, CURLOPT_RETURNTRANSFER, true);

		if(!empty($this->aOptions['useragent'])){
			curl_setopt($this->request, CURLOPT_USERAGENT, $this->aOptions['useragent']);
		}

		if(!empty($this->aOptions['timeout'])){
			curl_setopt($this->request, CURLOPT_TIMEOUT, $this->aOptions['timeout']);
		}

		if(!empty($this->aOptions['redirect']) && $this->aOptions['redirect']){
			curl_setopt($this->request, CURLOPT_FOLLOWLOCATION, 1);
		}

		if(!empty($this->aOptions['login']) && !empty($this->aOptions['password'])){
			curl_setopt($this->request,  CURLOPT_USERPWD, $this->aOptions['login'].':'.$this->aOptions['password']);
		}

		if(!empty($this->aOptions['method']) && 'POST' === strtoupper($this->aOptions['method'])){
			curl_setopt($this->request, CURLOPT_POST, true);
		}

		if(!empty($this->aOptions['formVars'])){
			d('setting method to POST');
			$r1 = \curl_setopt($this->request, CURLOPT_POST, true);
			d('set CURLOPT_POST '.$r1);
			$r2 = \curl_setopt($this->request, CURLOPT_POSTFIELDS, $this->aOptions['formVars']);
			d('set CURLOPT_POSTFIELDS: '.print_R($this->aOptions['formVars'], 1). ' ret: '.$r2);
		}

		if(!empty($this->aOptions['gzip'])){
			curl_setopt($this->request, CURLOPT_ENCODING, 'gzip');
		}

		if(!empty($this->aOptions['ip'])){
			curl_setopt($this->request, CURLOPT_INTERFACE, $this->aOptions['ip']);
		}

		return $this;
	}

	
	/**
	 * Set single curl option
	 * 
	 * @param string $name
	 * @param string $val
	 */
	public function setOption($name, $val){
		curl_setopt($this->request, constant($name), $val);
	}

	
	/**
	 * Destructor method to close open curl connection
	 * and free up resource
	 */
	public function __destruct(){
		if($this->request && is_resource($this->request)){
			@curl_close($this->request);
		}
	}

	
	/**
	 * Get value of charset
	 * as extracted from the
	 * Content-Type header
	 * Some servers have this info for the text content
	 * like html or xml or other type of text, but
	 * not all servers.
	 * So this value may not be available all the time,
	 * in which case the return value will be null
	 *
	 * @return mixed value of charset or null if not
	 * available.
	 *
	 */
	public function getCharset(){
		$contentType = $this->info['content_type'];
		if(!empty($contentType) && preg_match('/charset=([\S]+)/', $contentType, $matches)){

			return trim($matches[1]);
		}

		return null;
	}

	
	/**
	 * Getter for $this->info array
	 *
	 * @return array
	 */
	public function getCurlInfo(){
		return $this->info;
	}

	
	/**
	 * Getter for $this->body
	 * @return string body of http response
	 */
	public function getResponseBody(){
		return $this->body;
	}

	
	/**
	 * Getter for $this->httpResponseCode
	 * 
	 * @return int http response code
	 */
	public function getHttpResponseCode(){
		return (int)$this->httpResponseCode;
	}

	
	/**
	 * Get value of specific header
	 * if this header does not exists, will return empty string
	 * 
	 * @param string $sHeader
	 */
	public function getHeader($sHeader){
		$sHeader = strtolower($sHeader);

		return (array_key_exists($sHeader, $this->aResponseHeaders)) ? $this->aResponseHeaders[$sHeader]: '';
	}


	/**
	 * Returns value of Last-Modified header
	 * OR 'Date' header
	 * OR convert unix timestamp to date('r')
	 *
	 * @return string in the RFC 2822 date format
	 */
	public function getLastModified(){
		if(!empty($this->aResponseHeaders['last-modified'])){

			return $this->aResponseHeaders['last-modified'];

		} elseif(!empty($this->aResponseHeaders['date'])){

			return $this->aResponseHeaders['date'];
		}

		return date('r');
	}


	/**
	 * @return string value of 'Etag' header or empty string
	 * if Etag is not present
	 */
	public function getEtag(){
		return $this->getHeader('Etag');
	}


	public function getResponseHeaders(){
		return $this->aResponseHeaders;
	}

}
