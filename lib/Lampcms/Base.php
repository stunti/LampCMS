<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is lisensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 * 	  the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website's Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attibutes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2011 (or current year) ExamNotes.net inc.
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: @package_version@
 *
 *
 */


namespace Lampcms;

use Lampcms\Interfaces\RoleInterface;


/**
 * The reason for using this Base object and extending it
 * in WebPage is to be able to use some methods
 * from classes other than WebPage, which may also extend
 * this class
 * For example, a class may exist that accepts messages by email
 * Or accepts some data, including login in users using some
 * type of server other than web server
 *
 * @author Dmitri Snytkine
 *
 */
class Base extends LampcmsObject
{

	/**
	 * Premission required to access this script
	 * 
	 * @var string
	 */
	protected $permission;
	
	

	/**
	 * Special type of permission check where we don't
	 * need to check the specific permission but only
	 * require the user to be logged in. This is faster
	 * than a full Access Control check.
	 *
	 * @var bool
	 */
	protected $membersOnly = false;


	/**
	 * Special type of permission check where we don't
	 * need to check the specific permission but only
	 * require the user to be NOT logged in. This is faster
	 * than a full Access Control check.
	 *
	 * @var bool
	 */
	protected $guestsOnly = false;


	/**
	 *
	 * Flag used for memoization
	 * to speed up resolving isLoggedIn()
	 *
	 * @var bool
	 */
	protected $bLoggedIn;


	public function __construct(Registry $oRegistry){
		$this->oRegistry = $oRegistry;
	}


	/**
	 * Updates the value of last_login in LOGIN_LOG table
	 * along with Geo data and useragent
	 *
	 * @param integer $intUserId user id
	 *
	 * @param string $username_date in
	 * unix timestamp format
	 *
	 * @param string $login_type
	 * indicated how user connected:
	 * www, nntp, cookie, ftp, webdav
	 *
	 * @return object $this
	 */
	protected function updateLastLogin($intUserId = null, $username_date = '', $login_type = 'www'){
		$userId = (null !== $intUserId) ? (int)$intUserId : $this->oRegistry->Viewer->getUid();
		$i_ts = ( empty($username_date)) ? time() : (int)$username_date;
		$strIp = Request::getIP();
		$useragent = Request::getUserAgent();
		$aData = compact( 'i_ts', 'useragent', 'login_type' );

		$this->saveResourceLocation( $userId, $strIp, $aData, 'LOGIN_LOG', 'i_uid', true, true );

		return $this;

	}

	/**
	 * Given the $intResourceId and $ip this functon
	 * creates a record in RESOURCE_LOCATION table (or any other table name specified in arguments)
	 * It also checks that IP address is valid and public. Local, private, reserved or non-valid addresses will
	 * be ignored.
	 *
	 * @param string $ip ip address or host name from where resource was submitted
	 *
	 * @param array $arrExtra associative array of key=>value can be passed here with extra data
	 * this data will be added to geoIP array so that any additional data can then be inserted into
	 * database table together with GeoIP data.
	 *
	 * @param string $collection a name of mongo collection where the GeoIP data will be inserted
	 * this table must have specific column names and they must be of type NULL because none of the
	 * GeoIP data is guaranteed to be present in array.
	 *
	 * @param string $columnName a name of database table column that can be used instead of the default 'resouce_id'
	 * the value of $resourceId will be recorded in that column.
	 *
	 * @param boolean $bRecreate a false means to re-use previosly created GeoIP object if such object exists
	 * this can save some time if you need to do 2 or more consecutive ip to location lookups on the same ip address
	 *
	 * @return bool true or false
	 */
	public function saveResourceLocation($resourceId = '', $ip = '', array $arrExtra = array(),
	$collection = 'RESOURCE_LOCATION', $columnName = 'i_res_id',
	$bAddIp = false, $bRecreate = true)
	{
		/**
		 * Special case:
		 * the first argument can be instance of Message object
		 * or instance of File
		 * in such case all required arguments are in that object
		 */
		if (is_object( $resourceId )) {
			if ($resourceId instanceof MessageObject) {
				$ip = $resourceId->ip_address;
				$collection = $resourceId->geoTable;
				$columnName = 'messages_id';
				$arrExtra = array('useragent'=>$resourceId->useragent,
                                     'upload_method'=>$resourceId->upload_method);
				$resourceId = $resourceId->messages_id;
				$bAddIp = true;

			} elseif ($resourceId instanceof File) {
				$ip = $resourceId->ip;
				$resourceId = $resourceId->resource_id;
			}
		}

		if (empty($ip)) {
			e('Error: strIp is empty in object File');

			return false;
		}

		if (empty($resourceId)) {
			e('Error: intResourceId is empty in objectFile ');

			return false;
		}


		if (false === $ip = Ip::parseIpString( $ip )) {

			return true;
		}

		/**
		 * check to make sure the ip address
		 * is good and also a public IP
		 */
		$oCheckIp = new Ip();
		if (!$oCheckIp->isPublic( $ip )) {

			return true;
		}

		$boolSave = false;

		$oGeoLocation = Geoip::getGeoData($ip);

		if ( 0 === strlen($oGeoLocation->countryCode) && $collection == 'RESOURCE_LOCATION') {
			d( 'Did not find location for this ip: '.$ip );

			return true;
		}


		if (null !== $columnName) {
			$arrExtra[$columnName] = $resourceId;
		}

		if ($bAddIp) {
			$arrExtra['ip'] = $ip;
		}

		if(!is_object($oGeoLocation)){
			e('LampcmsError $this->oGeoLocation is not an object, its: '.gettype($this->oGeoLocation));

			return false;
		}

		$arrData = $arrExtra + $oGeoLocation->getData();
		d( '$arrData: '.print_r( $arrData, true ) );

		d('collName: '.$columnName);

		/**
		 * Ensure index on column $columnName
		 *
		 */
		$indexed = $this->oRegistry->Mongo->getCollection($collection)->ensureIndex(array($columnName => 1));
		d('$indexed: '.$indexed);
		$boolSave = $this->oRegistry->Mongo->insertData($collection, $arrData, null, __METHOD__);
		d( '$boolSave: '.$boolSave );

		return (bool)$boolSave;

	}


	/**
	 *
	 * Check if a user has permission
	 * either on a specific resource
	 * or on site's permission
	 *
	 * This is basically a wrapper for Zend_Acl isAllowed()
	 * method, but the order of params is different here
	 * because we tend to most often
	 * only have the privilege param and $role is
	 * usually a Viewer and $resource is usually omitted
	 * because we are checking a site-wide permission
	 *
	 * @param string $privilege name of privilege (like 'add_comments')
	 *
	 * @param object $role our User Object is fine because it implements Zned_Acl_Role_Interface
	 *
	 * @param mixed $resource object or string name of resource
	 *
	 * @return mixed object $this if everything is OK
	 * OR throws exception is access is denied
	 *
	 * @throws If permission is denied, then we throw a special
	 * Exception: Lampcms\AuthException if user is not logged in,
	 * which would cause the template to present a login form
	 * on the error page
	 *
	 * OR Lampcms\AccessException if user is logged in
	 * which would mean a user does not have appropriate
	 * access privileges
	 */
	public function checkAccessPermission($privilege = null, RoleInterface $role = null, $resource = null){

		d('$privilege: '.$privilege.' '.var_export($privilege, true));

		if(null === $privilege){
			d('$privilege is null');

			if(!isset($this->permission)){

				d('$this->permission not set');

				return $this;
			}

			$privilege = $this->permission;
		}

		/**
		 * If $role is not passed here
		 * then we use the current user ($this->oViewer)
		 * but we must reload the user details because
		 * otherwise the data may be somewhat stale - use object
		 * is stored in session and what if admin has banned
		 * the user after the user logged in or maybe
		 * admin demoted the user from moderator to
		 * normal user or assigned a user to 'spammers' group
		 * This is why we need the very latest user data,
		 * so we get the user object (User) from
		 * session ($this->oViewer usually points to object in session)
		 * then we call the reload() method which basically replaces that array
		 * of data with the fresh new array. The fresh new array is still
		 * taken via cache, so if user data has not changed, then the whole
		 * reload operation does not require even a single sql select
		 *
		 */
		d('role: '.$role. ' $this->oRegistry->Viewer: '.$this->oRegistry->Viewer);

		/**
		 * How not to reload the object?
		 * The only way is to NOT store Viewer in session at all
		 * if only storing uid in session then
		 * initViewer would always get data from USERS collection
		 * on every visit instead of from SESSION
		 * Will be easier to maintain, session objects will be smaller
		 * Can still have custom session handler to store
		 * location, username, avatar? Not sure yet
		 * If in initViewer will have something like $_SESSION['username']
		 * = Viewer->getScrenName().... then yes.
		 *
		 * But it would mean lots of calls to viewer object on every
		 * page load. Is this big deal to make extra 2 calls to already
		 * inflated object? No!
		 *
		 * Problem with this approach is that we will lose
		 * the class type. For example, if Viewer is TwitterUser
		 * or FacebookUser, then will will lose this ability to
		 * differentiate user types. It's just better to
		 * reload viewer here, it's not all that slow - Mongo
		 * select is fast!
		 *
		 */
		$role = (null !== $role) ? $role : $this->oRegistry->Viewer->reload();

		d('role: '.$role);

		/**
		 * oACL can be cached, which saves about 5-7 milliseconds
		 * on my dev machine. The downside is that if you
		 * edit acl.ini you must manually remove
		 * Acl key from cache. (from C_Cache collection)
		 */
		//$oACL = $this->oRegistry->Cache->Acl;
		$oACL = $this->oRegistry->Acl;//new \Lampcms\Acl\Acl();

		$roleID = $role->getRoleId();
		d('$roleID '.$roleID.' $privilege: '.$privilege);

		if(!$oACL->isAllowed($role, $resource, $privilege)){
			if(!$this->isLoggedin()){
				/**
				 * @todo translate string
				 */
				throw new AuthException('Please Register or Login to perform this action');
			}

			if(strstr($roleID, 'unactivated')){
				/**
				 * @todo
				 * Translate string
				 */
				throw new UnactivatedException('You have not confirmed email address<br>Go to <a href="/settings/">Settings</a> and confirm your email');
			}

			throw new AccessException("Your account does not have permission to perform this action");
		}

		return $this;
	}




	/**
	 * Checks the access permissions for current page
	 * based on values of $this->bMembersOnly,
	 * $this->bGuestsOnly and logged in status
	 * For example, if page is available only
	 * to logged in users, the exception will be
	 * throws in guest tries to access it
	 *
	 * @return object $this
	 *
	 * @throws LampcmsException if access level
	 * error is detected
	 */
	protected function checkLoginStatus(){
		if ($this->membersOnly && !$this->isLoggedIn()) {
			d('cp must login');
			throw new MustLoginException('You must login to access this page');
		}

		if($this->guestsOnly && $this->isLoggedIn()){
			d('not a guest!');
			throw new MustLoginException('This page cannot be accessed by a logged in user');
		}

		return $this;
	}

	/**
	 *
	 * Check to see if current viewer
	 * is a logged in user or guest
	 *
	 * @return bool true if logged in Viewer
	 * is registered user of false if is guest
	 */
	public function isLoggedIn(){

		if(!isset($this->bLoggedIn)){
			d('bLoggedIn not set');
			$this->bLoggedIn = !$this->oRegistry->Viewer->isGuest();
			d('bLoggedIn now: '.$this->bLoggedIn);
		}

		return $this->bLoggedIn;
	}

}
